# 1.2:理解を困難にする条件分岐のネスト

条件分岐は、プログラミングの基本制御ですね。

一方で、条件分岐をずさんに扱うと、悪魔となって開発者を苦しめることになります。

List1.3:何重にもネストしたロジック

下記は、RPGにおける魔法発動までの条件を実装した例です。

```ts
//生存しているか判定
if (0 < member.hitPoint) {
  // 行動可能か判定
  if(member.canAct()) {
    // 魔法力が残存しているかを判定
    if(magic.costMagicPoint <= member.magicPoint) {
      member.consumeMagicPoint(magic.costMagicPoint);
      member.chant(magic);
    }
  }
}
```

このように複数の条件に対して判定をかけるために入れ子の条件分岐を重ねることを「ネスト」といいます。

ネストが深くなるとコードの見通しがどんどん悪くなっていきます。

なんの冗談かと思うかもしれませんが、下記のようなコードが本当にあるのです。

List1.4:巨大なネスト

```ts
if(条件) {
  //
  // 数十から数百業に及ぶなにかの処理
  //
  if(条件) {
    //
    // 数十から数百業に及ぶなにかの処理
    //
    if(条件) {
      //
      // 数十から数百業に及ぶなにかの処理
      //
    }
    //
    // 数十から数百業に及ぶなにかの処理
    //
  }
  //
  // 数十から数百業に及ぶなにかの処理
  //
}
```

分岐ロジックを正確に把握できずに仕様変更を行うとバグの原因になります。

詳細は[6.1](../Chapter6/6.1:条件分岐のネストによる可読性低下.md)